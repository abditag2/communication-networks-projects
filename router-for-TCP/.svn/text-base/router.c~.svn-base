#include "router.h"

#define MAXDATASIZE 1024
#define _POSIX_X_SOURCE 199309


int main(int argc, char *argv[]){
		
	if (argc != 4) {
		fprintf(stderr,"not enough arguments, usage: ./router hostname managerport listenon\n");
	    exit(1);
	}

	char hostname[50], managerport[50], udpport[50] ; //holds the file path of output file (string)	

	strcpy(hostname, argv[1] ) ; 
	strcpy(managerport, argv[2] ) ; 
	strcpy(udpport, argv[3] ) ; 

//--The following code is from Beej's guide--//


	int sockfd, numbytes; //initialize the structures for creating a new socket
	unsigned char buf[MAXDATASIZE];
	struct addrinfo hints, *servinfo, *p;
	int rv;
	char s[INET6_ADDRSTRLEN];

	memset(&hints, 0, sizeof hints);
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	if ((rv = getaddrinfo(hostname, managerport, &hints, &servinfo)) != 0) {

		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
		return 1;
	}


	
	// loop through all the results and connect to the first we can
	for(p = servinfo; p != NULL; p = p->ai_next) {
		if ((sockfd = socket(p->ai_family, p->ai_socktype,
				p->ai_protocol)) == -1) {
			perror("client: socket");
			continue;
		}

		if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
			close(sockfd);
			perror("client: connect");
			continue;
		}

		break;
	}

	if (p == NULL) {
		fprintf(stderr, "client: failed to connect\n");
		return 2;
	}


	inet_ntop(p->ai_family, get_in_addr((struct sockaddr *)p->ai_addr), s, sizeof s);
			
	printf("client: connecting to %s\n", s);

	freeaddrinfo(servinfo); // all done with this structure	


	if( send(sockfd, "HELO\n", 5, 0) != 5 ) 
		fprintf(stderr, "client: failed to send HELO\n");


	char addr[10] ; 
	char* recv_msg ; 

	while (1){
		

		if (recv(sockfd, buf, 1024, 0) != 0 )		
		{				
			strtok(buf, " " ) ;
			strcpy(addr , strtok(NULL, " \n" )) ; 
			break ;		
		}
		 
	}

	printf( "manager replied with address %s\n", addr);

	char msg[80] ; 
	strcpy(msg, "HOST ") ; 
	strcat(msg, hostname) ;
	strcat(msg, " " ) ;  
	strcat(msg, udpport) ;
	strcat(msg, "\n") ;
 
	printf("%s", msg ) ;
	
	int j = 0 ;  
	for(j = 0 ; j < 80 ; j ++ ) 
		if (msg[j] == '\n' ) 
			break ; 


	if( send(sockfd, msg , j+1, 0) != j+1 ) 
		fprintf(stderr, "client: failed to send HELO\n");

	
	while (1){

		if (recv(sockfd, buf, 3, 0) == 3 )		
		{				

			recv_msg = strtok(buf, " \n" ) ;
			printf("%s\n", recv_msg ) ; 
			break ;		
		}
		else 
			printf("waiting for OK\n");
		 
	}



	if( send(sockfd, "NEIGH?\n" , 7, 0) != 7 ) 
		fprintf(stderr, "client: failed to send NEIGH?\n");


	strcpy(buf,"") ; 


	//initliaze the linked_list

        node *start,*temp;
        start = (node *)malloc(sizeof(node)); 
        temp = start;
        temp -> next = NULL;
        /* Here in this code, we take the first node as a dummy node.
           The first node does not contain data, but it used because to avoid handling special cases
           in insert and delete functions.

         */

	char temp_msg_arr[100];
	char* temp_msg ; 
	while (1){

		if (recv(sockfd, buf, 100, 0) != 0 )		

		{	
			printf("%s\n", buf ) ;
			int j = 0 ;

			strcpy(temp_msg_arr, strtok(buf, " ")) ; 
			if (strcmp(temp_msg_arr, "NEIGH") == 0) 
			{	
				node* new_node ;
				new_node = get_new_node() ; 
				temp_msg = strtok(NULL," \n") ; 
				strcpy(new_node->addr , temp_msg) ;
				temp_msg = strtok(NULL," \n") ;
				strcpy(new_node->localhost, temp_msg );

				temp_msg = strtok(NULL," \n") ;
				strcpy(new_node->udpport, temp_msg );
				strcpy(temp_msg_arr, strtok(NULL," \n")) ;
				new_node->cost = atoi(temp_msg_arr);

				insert(start, new_node) ; 

				temp_msg = strtok(NULL," \n")  ; 
				if (temp_msg != NULL) { 
					strcpy(temp_msg_arr, temp_msg) ;
		
					if (strcmp(temp_msg_arr,"DONE") == 0 ) 
					{
						printf("DONE found!\n") ; 
						break ;
					}
					else 
					{
						printf("DONE not found!\n") ; 
					}
				}
			}

		}
		 
	}



	if( send(sockfd, "READY\n" , 6, 0) != 6 ) 
		fprintf(stderr, "client: failed to send NEIGH?\n");


	while (1){

		if (recv(sockfd, buf, 3, 0) == 3 )		
		{				

			recv_msg = strtok(buf, " \n" ) ;
			printf("%s\n", recv_msg ) ; 
			break ;		
		}
		else 
			printf("waiting for OK\n");
		 
	}

//check for the messages from the manager

	node* node_to_be_changed;
	char msg_arr[50] ; 
	while (1) 
	{
		if (recv(sockfd, buf, 100, 0) > 0 )		
		{				
			
			strcpy(msg_arr, strtok(buf,"\n")) ; 

			strcpy(temp_msg_arr, strtok(msg_arr," \n")) ; 
			printf("%s\n",temp_msg_arr) ; 

			if ( strcmp(temp_msg_arr, "END") == 0) {

				if( send(sockfd, "BYE" , strlen("BYE"), 0) != strlen("BYE") ) 
					fprintf(stderr, "client: failed to send cost OK\n");

				close(sockfd); //clean up the socket file descriptor


			}	

 	
			if ( strcmp(temp_msg_arr, "LINKCOST") == 0) {

				char node1[5], node2[5], cost_arr[5] ;
				int cost_int ; 

 				strcpy(node1, strtok(NULL," \n")) ; 
				strcpy(node2, strtok(NULL," \n")) ; 
				strcpy(cost_arr, strtok(NULL," \n")) ; 
				cost_int = atoi(cost_arr) ; 

				printf("list: %s\n", node1);
				printf("list: %s\n", node2);
				printf("list: %s\n", addr);
				printf("list: %d\n", cost_int);

				if ( strcmp(node1 , addr) == 0 )
				{
					printf("node2 changed!") ; 
					node_to_be_changed = find(start, node2) ;
					node_to_be_changed->cost = cost_int ; 
				}
				else if (strcmp(node2 , addr) == 0) 
				{
					printf("node1 changed!") ; 
					node_to_be_changed = find(start, node1) ;
					node_to_be_changed->cost = cost_int ; 
				}	
				else
				{
					printf("none changed!");
				}

				sprintf(temp_msg_arr, "COST %d OK", cost_int) ; 
				printf("%s",temp_msg_arr) ;
   
				if( send(sockfd, temp_msg_arr , strlen(temp_msg_arr), 0) != strlen(temp_msg_arr) ) 
					fprintf(stderr, "client: failed to send cost OK\n");



			}

		}
	}


		




	return 0;
}


/* get_in_addr - Helper function to fill sockaddr struct
 */

void *get_in_addr(struct sockaddr *sa)
{
	if (sa->sa_family == AF_INET) {
		return &(((struct sockaddr_in*)sa)->sin_addr);
	}

	return &(((struct sockaddr_in6*)sa)->sin6_addr);
}

